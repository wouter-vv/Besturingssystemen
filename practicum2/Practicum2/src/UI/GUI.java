/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package UI;


import Object.AddressFrame;
import Object.AddressPage;
import Object.InstructionObject;
import Object.Page;
import Object.PageTableEntry;
import Object.Frame;
import java.io.File;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.ListSelectionModel;
import javax.swing.filechooser.FileSystemView;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 *
 * @author Wouter Vande Velde <wouter.vandevelde@student.odisee.be>
 */
public class GUI extends javax.swing.JFrame {

    // a list because the amount of processes is not known yet
    List<PageTableEntry[]> pageTables = new ArrayList<PageTableEntry[]>();
    // fixed amount of 12 frames
    Page[] RAM = new Page[12];
    // fixed amount of 16 pages
    Frame[] VirtualMemory = new Frame[16];
    
    // tracks which processes are in the RAM, with a queue to know the oldest
    List<Integer> ProcessesInRAM = new ArrayList<Integer>();
    
    //counts the total amount of unique processes and keeps the IDs
    List<Integer> processIDs = new ArrayList<Integer>();
    
    //list with all the instructions
    List<InstructionObject> instructions;
    
    final int PAGESINRAM = 12;
    
    final int PAGESIZE = (int)Math.pow(2, 12);
    
    /**
     * Creates new form GUI
     */
    public GUI() {
        initComponents();
        try {
            JFileChooser jfc = new JFileChooser(FileSystemView.getFileSystemView().getHomeDirectory());
            int returnValue = jfc.showOpenDialog(null);
            if (returnValue == JFileChooser.APPROVE_OPTION) {
                File selectedFile = jfc.getSelectedFile();
                
                File fXmlFile = new File(selectedFile.getAbsolutePath());
                DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
                DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
                Document doc = dBuilder.parse(fXmlFile);

                doc.getDocumentElement().normalize();

                System.out.println("Root element :" + doc.getDocumentElement().getNodeName());

                NodeList nList = doc.getElementsByTagName("instruction");

                System.out.println("----------------------------");
                
                instructions = new ArrayList<>();
                
                
                for (int temp = 0; temp < nList.getLength(); temp++) {

                        Node nNode = nList.item(temp);

                        if (nNode.getNodeType() == Node.ELEMENT_NODE) {

                                Element eElement = (Element) nNode;

                                int id = Integer.parseInt(eElement.getElementsByTagName("processID").item(0).getTextContent());
                                if (!processIDs.contains(id)) processIDs.add(id);
                                String operation = eElement.getElementsByTagName("operation").item(0).getTextContent();
                                int address = Integer.parseInt(eElement.getElementsByTagName("address").item(0).getTextContent()); 
                                instructions.add(new InstructionObject(id, operation, address));
                        }
                      
                }
                System.out.println("finished reading data");
                // create empty pageTables for the amount of processes
                for(int i = 0; i < processIDs.size(); i++) {
                    //PageTableEntry p = new PageTableEntry(0, 0, 0, 1);
                    PageTableEntry[] l = new PageTableEntry[4096];
                    pageTables.add(l);
                }
                // assign all the pages in the RAM to a dummy process
                for (int i = 0; i < RAM.length; i++) {
                    RAM[i] = new Page(-1, new AddressPage[4096]);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        ButtonSingle = new javax.swing.JButton();
        ButtonAll = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        ListPageTable = new javax.swing.JList<>();
        jLabel1 = new javax.swing.JLabel();
        LabelCurrentProcess = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        ButtonSingle.setText("single insctruction");
        ButtonSingle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonSingleActionPerformed(evt);
            }
        });

        ButtonAll.setText("Execute whole file");
        ButtonAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonAllActionPerformed(evt);
            }
        });

        jScrollPane1.setViewportView(ListPageTable);

        jLabel1.setText("Current Process:");

        LabelCurrentProcess.setText("jLabel2");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(ButtonSingle)
                            .addComponent(jLabel1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(LabelCurrentProcess)
                            .addComponent(ButtonAll))))
                .addContainerGap(668, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ButtonSingle)
                    .addComponent(ButtonAll))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(LabelCurrentProcess))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 61, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 310, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(26, 26, 26))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void ButtonAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonAllActionPerformed
        int oldAmountOfProcessesInRAM = 0;
        boolean reorganiseRAM = false;
        for (int clock = 0; clock < instructions.size(); clock++) {
        //for (InstructionObject instruction : instructions) {
            if (instructions.get(clock).getOperation().equals("Start")) {
                ProcessesInRAM.add(instructions.get(clock).getId());
                reorganiseRAM = true;
            } else if (instructions.get(clock).getOperation().equals("Terminate")) {
                for (int j = 0; j < ProcessesInRAM.size(); j++) {
                    if (instructions.get(clock).getId() == ProcessesInRAM.get(j)) {
                        ProcessesInRAM.remove(j);
                    } else {
                        // if the instruction asks to terminate but there is no process to terminate
                        System.out.println("something went seriously wrong");
                    }
                    reorganiseRAM = true;
                }
            } else {
                int address = instructions.get(clock).getAddress();
                int frameNumber = address/PAGESIZE;
                int offset = instructions.get(clock).getAddress()-(frameNumber*PAGESIZE);
                
                AddressFrame x = VirtualMemory[frameNumber].getFrame()[offset];
                VirtualMemory[frameNumber].getFrame()[offset].setAddress(address);
                VirtualMemory[frameNumber].getFrame()[offset].setOffset(offset);
                
            }
            
            // if a new process has started or one is terminated, reorganise RAM
            if(reorganiseRAM) {
                if(ProcessesInRAM.size()==0) {
                    
                } else {
                    int pagesPerProcess = PAGESINRAM/ProcessesInRAM.size();
                    // a new process is added
                    if(oldAmountOfProcessesInRAM<ProcessesInRAM.size()) {
                        // create a temporary new RAM to see the dedicated pages
                        List<Page> p = new ArrayList<Page>();
                        for (int i = 0; i < pagesPerProcess; i++) {
                            for (int j = 0; j < ProcessesInRAM.size(); j++) {
                                p.add(new Page(ProcessesInRAM.get(i), new AddressPage[4096])); 
                            }
                        }
                        for (int i = 0; i < RAM.length; i++) {
                            // if a page is different, write the old page to VM
                            if(p.get(i).getDedicatedProcessID() != RAM[i].getDedicatedProcessID()) {
                                // TODO Content of RAM[i] written to Virtual Memory
                                
                                
                                RAM[i] = p.get(i);
                                
                            }
                        }
                    }
                    
                }
                reorganiseRAM = false;
            } else {
                
            }
        }
        
        
    }//GEN-LAST:event_ButtonAllActionPerformed
    int currentProcess = -1;
    private void ButtonSingleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ButtonSingleActionPerformed
        currentProcess++;
        this.remove(ListPageTable);
        ListPageTable = new JList(pageTables.get(currentProcess));
        LabelCurrentProcess.setText(currentProcess + "");
        this.add(ListPageTable);
        

        ListPageTable.setBounds(10,100, 75,75);  
        ListPageTable.setSize(500, 300);
        this.setLayout(null);  
        this.setVisible(true);  
    }//GEN-LAST:event_ButtonSingleActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ButtonAll;
    private javax.swing.JButton ButtonSingle;
    private javax.swing.JLabel LabelCurrentProcess;
    private javax.swing.JList<String> ListPageTable;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}
