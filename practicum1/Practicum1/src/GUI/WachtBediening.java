/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package GUI;

import Strategies.FirstComeFirstServe;
import Strategies.RoundRobinQ8;
import Strategies.ShortestJobFirst;
import Strategies.ShortestRemaingTime;
import Strategies.HighestResponseRatioNext;
import Strategies.MultilevelFeedback;
import java.awt.BorderLayout;
import java.awt.Color;
import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.PriorityQueue;
import javax.swing.JFileChooser;
import javax.swing.filechooser.FileSystemView;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.title.TextTitle;
import org.jfree.chart.title.Title;
import org.jfree.data.category.DefaultCategoryDataset;
import org.jfree.data.xy.DefaultXYDataset;
import org.jfree.data.xy.XYDataset;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import Objects.Process;
import Objects.ProcessHRRN;
import Objects.ProcessSRT;
import Strategies.RoundRobinQ2;
import java.util.Comparator;

/**
 *
 * @author Thomas
 */
public class WachtBediening extends javax.swing.JFrame {

    /**
     * Creates new form GUI
     */
    public WachtBediening() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panel = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        panel.setBackground(new java.awt.Color(204, 204, 204));
        panel.setLayout(new java.awt.BorderLayout());

        jButton1.setText("Start");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(panel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jButton1)
                        .addGap(0, 1412, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(panel, javax.swing.GroupLayout.PREFERRED_SIZE, 482, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 8, Short.MAX_VALUE)
                .addComponent(jButton1))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        try {
            FirstComeFirstServe fcfs = new FirstComeFirstServe();
            ShortestJobFirst sjf = new ShortestJobFirst();
            RoundRobinQ8 rr8 = new RoundRobinQ8();
            RoundRobinQ2 rr2 = new RoundRobinQ2();
            ShortestRemaingTime srt = new ShortestRemaingTime();
            HighestResponseRatioNext hrrn = new HighestResponseRatioNext();
            MultilevelFeedback mlfb = new MultilevelFeedback();
            JFileChooser jfc = new JFileChooser(FileSystemView.getFileSystemView().getHomeDirectory());
            int returnValue = jfc.showOpenDialog(null);
            if (returnValue == JFileChooser.APPROVE_OPTION) {
                File selectedFile = jfc.getSelectedFile();
                
                File fXmlFile = new File(selectedFile.getAbsolutePath());
                DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
                DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
                Document doc = dBuilder.parse(fXmlFile);

                doc.getDocumentElement().normalize();

                System.out.println("Root element :" + doc.getDocumentElement().getNodeName());

                NodeList nList = doc.getElementsByTagName("process");

                System.out.println("----------------------------");
                
                List<Process> processes1 = new ArrayList<>();
                List<Process> processes2 = new ArrayList<>();
                List<Process> processes3 = new ArrayList<>();
                List<Process> processes4 = new ArrayList<>();
                List<ProcessSRT> processes5 = new ArrayList<>();
                List<ProcessHRRN> processes6 = new ArrayList<>();
                List<Process> processes7 = new ArrayList<>();
                
                for (int temp = 0; temp < nList.getLength(); temp++) {

                        Node nNode = nList.item(temp);

                        if (nNode.getNodeType() == Node.ELEMENT_NODE) {

                                Element eElement = (Element) nNode;

                                int id = Integer.parseInt(eElement.getElementsByTagName("pid").item(0).getTextContent());
                                int arrivaltime = Integer.parseInt(eElement.getElementsByTagName("arrivaltime").item(0).getTextContent());
                                int servicetime = Integer.parseInt(eElement.getElementsByTagName("servicetime").item(0).getTextContent()); 
                                processes1.add(new Process(id, arrivaltime, servicetime, 0, 0, 0, 0, 0, servicetime));
                                processes2.add(new Process(id, arrivaltime, servicetime, 0, 0, 0, 0, 0, servicetime));
                                processes3.add(new Process(id, arrivaltime, servicetime, 0, 0, 0, 0, 0, servicetime));
                                processes4.add(new Process(id, arrivaltime, servicetime, 0, 0, 0, 0, 0, servicetime));
                                processes5.add(new ProcessSRT(id, arrivaltime, servicetime, 0, 0, 0, 0, 0, servicetime));
                                processes6.add(new ProcessHRRN(id, arrivaltime, servicetime, 0, 0, 0, 0, 0, servicetime, 0));
                                processes7.add(new Process(id, arrivaltime, servicetime, 0, 0, 0, 0, 0, servicetime));
                        }
                      
                }

                System.out.println("finished reading data");
                // create threads here
                processes1 = fcfs.startFirstComeFirstServe(processes1);
                Collections.sort(processes1);
                processes2 = sjf.startShortestJob(processes2);
                Collections.sort(processes2);
                processes3 = rr8.startRoundRobin(processes3);
                Collections.sort(processes3);
                processes4 = rr2.startRoundRobin(processes4);
                Collections.sort(processes4);
                processes5 = srt.startShortestRemaining(processes5);
                Collections.sort(processes5);
                processes6 = hrrn.startHighestResponseRatioNext(processes6);
                Collections.sort(processes6,  Comparator.comparing(ProcessHRRN::getServicetime));
                processes7 = mlfb.startMultiLevelFeedback(processes7);
                Collections.sort(processes7);
                


                DefaultXYDataset dataset = new DefaultXYDataset();
                        
                double[][] arrayFCFS = new double[2][processes1.size()];
                double[][] arraySJF = new double[2][processes1.size()];
                double[][] arrayRR8 = new double[2][processes1.size()];
                double[][] arrayRR2 = new double[2][processes1.size()];
                double[][] arraySRT = new double[2][processes1.size()];
                double[][] arrayHRRN = new double[2][processes1.size()];
                double[][] arrayMLFB = new double[2][processes1.size()];
                
                double[][] arrayFCFSPercentile = new double[2][100];
                double[][] arraySJFPercentile = new double[2][100];
                double[][] arrayRR8Percentile = new double[2][100];
                double[][] arrayRR2Percentile = new double[2][100];
                double[][] arraySRTPercentile = new double[2][100];
                double[][] arrayHRRNPercentile = new double[2][100];
                double[][] arrayMLFBPercentile = new double[2][100];
                
                for(int i = 0; i < processes1.size(); i++) {
                    arrayFCFS[0][i]= processes1.get(i).getServicetime();
                    arrayFCFS[1][i]=processes1.get(i).getWaitingtime();
                    arraySJF[0][i]= processes2.get(i).getServicetime();
                    arraySJF[1][i]= processes2.get(i).getWaitingtime();
                    arrayRR8[0][i]= processes3.get(i).getServicetime();
                    arrayRR8[1][i]= processes3.get(i).getWaitingtime();
                    arrayRR2[0][i]= processes4.get(i).getServicetime();
                    arrayRR2[1][i]= processes4.get(i).getWaitingtime();
                    arraySRT[0][i]= processes5.get(i).getServicetime();
                    arraySRT[1][i]= processes5.get(i).getWaitingtime();
                    arrayHRRN[0][i]= processes6.get(i).getServicetime();
                    arrayHRRN[1][i]= processes6.get(i).getWaitingtime();
                    arrayMLFB[0][i]= processes7.get(i).getServicetime();
                    arrayMLFB[1][i]= processes7.get(i).getWaitingtime();
                }
                // percentile * amountOfPercentiles = array.length
                int valuesInPercentile = arrayFCFS[0].length/100;
                int amountOfPercentiles = arrayFCFS[0].length/valuesInPercentile;
                
                for(int i = 0; i < amountOfPercentiles; i++) {
                    for(int j = 0; j < valuesInPercentile; j++) {
                         arrayFCFSPercentile[1][i] += arrayFCFS[1][j+i*valuesInPercentile];
                         arraySJFPercentile[1][i] += arraySJF[1][j+i*valuesInPercentile];
                         arrayRR8Percentile[1][i] += arrayRR8[1][j+i*valuesInPercentile];
                         arrayRR2Percentile[1][i] += arrayRR2[1][j+i*valuesInPercentile];
                         arraySRTPercentile[1][i] += arraySRT[1][j+i*valuesInPercentile];
                         arrayHRRNPercentile[1][i] += arrayHRRN[1][j+i*valuesInPercentile];
                         arrayMLFBPercentile[1][i] += arrayMLFB[1][j+i*valuesInPercentile];
                    }
                    arrayFCFSPercentile[1][i]/=valuesInPercentile;
                    arraySJFPercentile[1][i]/=valuesInPercentile;
                    arrayRR8Percentile[1][i]/=valuesInPercentile;
                    arrayRR2Percentile[1][i]/=valuesInPercentile;
                    arraySRTPercentile[1][i]/=valuesInPercentile;
                    arrayHRRNPercentile[1][i]/=valuesInPercentile;
                    arrayMLFBPercentile[1][i]/=valuesInPercentile;
                    
                    // +1 so the graph starts at 1 until 100 (not 0-99)
                    arrayFCFSPercentile[0][i] = i*(amountOfPercentiles/100)+1;
                    arraySJFPercentile[0][i] = i*(amountOfPercentiles/100)+1;
                    arrayRR8Percentile[0][i] = i*(amountOfPercentiles/100)+1;
                    arrayRR2Percentile[0][i] = i*(amountOfPercentiles/100)+1;
                    arraySRTPercentile[0][i] = i*(amountOfPercentiles/100)+1;
                    arrayHRRNPercentile[0][i] = i*(amountOfPercentiles/100)+1;
                    arrayMLFBPercentile[0][i] = i*(amountOfPercentiles/100)+1;
                }          
                
                dataset.addSeries("FCFS", arrayFCFSPercentile);
                dataset.addSeries("SJF", arraySJFPercentile);
                dataset.addSeries("RR8", arrayRR8Percentile);
                dataset.addSeries("RR2", arrayRR2Percentile);
                dataset.addSeries("SRT", arraySRTPercentile);    
                dataset.addSeries("HRRN", arrayHRRNPercentile);        
                dataset.addSeries("MLFB", arrayMLFBPercentile);          
                
                JFreeChart chart = ChartFactory.createXYLineChart("Waiting time in function to service time with "+ processes1.size() + " Processes", "ServiceTime", "Waitingtime", (XYDataset) dataset);//createLineChart("", "", "", dataset, PlotOrientation.VERTICAL, true, true, false);
                XYPlot xyPlot = chart.getXYPlot();
                xyPlot.setRangeGridlinePaint(Color.BLACK);
                
                final NumberAxis rangeAxis = (NumberAxis) xyPlot.getRangeAxis();
                rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
                rangeAxis.setAutoRangeIncludesZero(true);
                
                ChartPanel chartPanel = new ChartPanel(chart);
                panel.removeAll();
                panel.add(chartPanel, BorderLayout.CENTER);
                panel.validate();
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(WachtBediening.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(WachtBediening.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(WachtBediening.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(WachtBediening.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new WachtBediening().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JPanel panel;
    // End of variables declaration//GEN-END:variables
}
